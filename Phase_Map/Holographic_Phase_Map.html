<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HoloMap Accelerated</title>
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'Courier New', monospace;
            touch-action: none; /* Блокируем зум */
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85); z-index: 10;
            transition: opacity 0.5s;
        }
        
        button {
            background: transparent; color: #00ffcc;
            border: 2px solid #00ffcc; padding: 20px 40px;
            font-size: 18px; font-weight: bold; border-radius: 50px;
            margin: 15px; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }
        button:active { background: #00ffcc; color: #000; }
        
        #hud {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 5px #000;
        }
        .stat-main { font-size: 24px; font-weight: bold; color: #fff; }
        .stat-sub { font-size: 14px; color: #aaa; margin-top: 5px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1 style="color:white; margin-bottom:30px; text-shadow:0 0 10px #fff">HOLOGRAPHIC MAP</h1>
        <button id="btn-full">1. FULLSCREEN</button>
        <button id="btn-conn">2. CONNECT BLE</button>
    </div>

    <div id="hud">
        <div class="stat-main" id="st-main">READY</div>
        <div class="stat-sub" id="st-sub">Waiting for device...</div>
    </div>

    <canvas id="cvs"></canvas>

<script>
// === CONFIG ===
const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const CHAR_UUID    = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const FS = 250;
const FFT_SIZE = 256;
const CHANNELS = 8;
const UV_SCALE = (1.2 / 32 / 8388607.0) * 1e6;

// === STATE ===
let isConnected = false;
let packetBuffer = new Uint8Array();
// Ring buffers for 8 channels
let chBuffers = Array.from({length: 8}, () => new Float32Array(FFT_SIZE).fill(0));

// === AUDIO ===
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let synthOsc, synthGain, noiseGain;

function initAudio() {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    
    // Alpha Drone
    synthOsc = audioCtx.createOscillator();
    synthGain = audioCtx.createGain();
    synthOsc.connect(synthGain).connect(audioCtx.destination);
    synthOsc.type = 'sine';
    synthOsc.frequency.value = 100;
    synthGain.gain.value = 0;
    synthOsc.start();

    // Muscle Noise
    const nBuf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
    const d = nBuf.getChannelData(0);
    for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
    
    const noise = audioCtx.createBufferSource();
    noise.buffer = nBuf;
    noise.loop = true;
    noiseGain = audioCtx.createGain();
    noiseGain.gain.value = 0;
    noise.connect(noiseGain).connect(audioCtx.destination);
    noise.start();
}

// === BLE HANDLER ===
async function connect() {
    try {
        initAudio();
        const dev = await navigator.bluetooth.requestDevice({
            filters: [{services: [SERVICE_UUID]}]
        });
        
        const server = await dev.gatt.connect();
        const svc = await server.getPrimaryService(SERVICE_UUID);
        const char = await svc.getCharacteristic(CHAR_UUID);
        
        await char.startNotifications();
        char.addEventListener('characteristicvaluechanged', onData);
        
        // Hide UI
        document.getElementById('ui-layer').style.opacity = 0;
        setTimeout(() => document.getElementById('ui-layer').style.display='none', 500);
        
        isConnected = true;
        drawLoop();
        
    } catch(e) {
        alert("Connection error: " + e);
    }
}

function onData(e) {
    const val = new Uint8Array(e.target.value.buffer);
    const tmp = new Uint8Array(packetBuffer.length + val.length);
    tmp.set(packetBuffer); tmp.set(val, packetBuffer.length);
    packetBuffer = tmp;

    // Robust parsing (33 bytes)
    while(packetBuffer.length >= 33) {
        let head = -1;
        // Find header 0xA0
        for(let i=0; i<packetBuffer.length-32; i++) {
            if(packetBuffer[i]===0xA0 && packetBuffer[i+32]===0xC0) {
                head = i; break;
            }
        }
        
        if(head === -1) {
            // Keep last 32 bytes just in case split happens there
            if(packetBuffer.length > 64) packetBuffer = packetBuffer.slice(-32);
            break;
        }
        
        if(head > 0) {
            packetBuffer = packetBuffer.slice(head);
            continue;
        }

        // Parse Packet
        for(let c=0; c<8; c++) {
            let v = (packetBuffer[2+c*3]<<16) | (packetBuffer[3+c*3]<<8) | packetBuffer[4+c*3];
            if(v & 0x800000) v -= 0x1000000;
            // Update Ring Buffer
            chBuffers[c].set(chBuffers[c].subarray(1));
            chBuffers[c][FFT_SIZE-1] = v * UV_SCALE;
        }
        
        packetBuffer = packetBuffer.slice(33);
    }
}

// === DSP & RENDER ===
const canvas = document.getElementById('cvs');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize
let w, h, cx, cy, rad;

function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    cx = w/2; cy = h/2;
    rad = Math.min(cx, cy) * 0.95;
}
window.onresize = resize;
resize();

// Pre-calc window
const win = new Float32Array(FFT_SIZE);
for(let i=0; i<FFT_SIZE; i++) win[i] = 0.5*(1-Math.cos(2*Math.PI*i/(FFT_SIZE-1)));

function drawLoop() {
    if(!isConnected) return;

    // 1. DSP: Average Bipolar Signal
    const sig = new Float32Array(FFT_SIZE);
    for(let i=0; i<FFT_SIZE; i++) {
        let s = 0;
        // Ch0-Ch1, Ch1-Ch2... Ring
        for(let c=0; c<8; c++) {
            s += (chBuffers[c][i] - chBuffers[(c+1)%8][i]);
        }
        sig[i] = s/8.0;
    }

    // 2. FFT
    const mags = new Float32Array(FFT_SIZE/2);
    const phases = new Float32Array(FFT_SIZE/2);
    
    for(let k=0; k<FFT_SIZE/2; k++) {
        let re=0, im=0;
        for(let n=0; n<FFT_SIZE; n++) {
            const phi = (2*Math.PI*k*n)/FFT_SIZE;
            const v = sig[n] * win[n];
            re += v * Math.cos(phi);
            im -= v * Math.sin(phi);
        }
        mags[k] = Math.sqrt(re*re + im*im);
        phases[k] = Math.atan2(im, re);
    }

    // 3. FEATURES
    let alpha=0, beta=0, gamma=0;
    let domF=0, maxM=0;
    
    // Start from 2Hz (index 2)
    for(let k=2; k<mags.length; k++) {
        const f = k * (FS/FFT_SIZE);
        if(f > 70) break;
        
        // Whitening for visualization
        const m = mags[k] * (f * 0.5);
        
        if(f>=8 && f<=13) alpha += m;
        if(f>=15 && f<=30) beta += m;
        if(f>=35) gamma += m;
        
        if(f<35 && m>maxM) { maxM=m; domF=f; }
    }
    
    const erd = alpha / (beta + 0.1);

    // 4. AUDIO FEEDBACK
    const now = audioCtx.currentTime;
    if(gamma > 200) {
        // Muscle
        noiseGain.gain.setTargetAtTime(0.3, now, 0.1);
        synthGain.gain.setTargetAtTime(0, now, 0.1);
        document.getElementById('st-main').innerText = "MUSCLE EMG";
        document.getElementById('st-main').style.color = "#ff0055";
    } else {
        // Neuro
        noiseGain.gain.setTargetAtTime(0, now, 0.2);
        
        let vol = (erd > 1.5) ? Math.min(0.8, (erd-1.5)*0.5) : 0;
        synthGain.gain.setTargetAtTime(vol, now, 0.3);
        synthOsc.frequency.setTargetAtTime(80 + domF*8, now, 0.3);
        
        document.getElementById('st-main').innerText = (erd > 1.5) ? "ALPHA STATE" : "FOCUS STATE";
        document.getElementById('st-main').style.color = (erd > 1.5) ? "#00ffcc" : "#aaaaaa";
    }
    document.getElementById('st-sub').innerText = `ERD: ${erd.toFixed(2)} | Peak: ${domF.toFixed(1)} Hz`;

    // 5. RENDER (ACCELERATED)
    
    // Trail effect (Fade)
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; // Fast fade
    ctx.fillRect(0, 0, w, h);
    
    // Grid
    ctx.globalCompositeOperation = 'lighter';
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, rad*0.25, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.5, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.75, 0, Math.PI*2);
    ctx.stroke();

    // Spectrum Particles
    for(let k=4; k<mags.length; k++) {
        const f = k * (FS/FFT_SIZE);
        if(f > 100) break;
        
        // Data
        const m = mags[k] * (f * 0.4); // Whitening
        const ph = phases[k];
        
        // Polar Pos
        const r = (f / 100.0) * rad;
        const a = ph;
        
        const x = cx + Math.cos(a) * r;
        const y = cy + Math.sin(a) * r;
        
        // Visualization Logic
        let hue = 240 - (f * 2.5); // Blue -> Red
        let size = 3 + m * 0.5;
        let bright = 50;
        
        if(gamma > 200 && f > 30) {
            hue = 0; bright = 70; // Red sparks
        } else if(erd > 2.0 && f>=8 && f<=13) {
            hue = 170; bright = 80; size *= 1.5; // Cyan glow
        }
        
        if(m > 1.0) { // Threshold to draw
            ctx.fillStyle = `hsla(${hue}, 100%, ${bright}%, ${Math.min(1, m/10)})`;
            // Square is faster than Arc on mobile GPU
            const s2 = size/2;
            ctx.fillRect(x-s2, y-s2, size, size);
        }
    }

    requestAnimationFrame(drawLoop);
}

// UI
document.getElementById('btn-full').onclick = () => document.documentElement.requestFullscreen();
document.getElementById('btn-conn').onclick = connect;

</script>
</body>
</html>
