<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neuro Radar Fixed</title>
    <style>
        body { 
            margin: 0; 
            background-color: #000; 
            color: #fff; 
            font-family: 'Courier New', monospace; 
            overflow: hidden; 
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            transition: opacity 0.5s;
            width: 100%;
        }

        button { 
            pointer-events: auto;
            background: rgba(0, 255, 0, 0.1); 
            color: #0f0; 
            border: 2px solid #0f0; 
            padding: 20px 40px; 
            font-size: 20px; 
            font-weight: bold; 
            border-radius: 50px;
            cursor: pointer; 
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            margin: 10px;
        }
        
        button:active { background: #0f0; color: #000; }

        #status-text {
            font-size: 16px;
            color: #aaa;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1 style="text-shadow: 0 0 15px #fff;">NEURO RADAR</h1>
        <div id="status-text">SYSTEM READY</div>
        <button id="btn-full">1. FULLSCREEN</button>
        <br>
        <button id="btn-connect">2. CONNECT</button>
    </div>

    <canvas id="radar"></canvas>

<script>
// === CONFIG ===
const BLE_SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const BLE_CHAR_UUID    = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const FS = 250;
const FFT_SIZE = 256; 
const CHANNELS = 8;
const UV_SCALE = (1.2 / 32 / 8388607.0) * 1e6;

// === STATE ===
let isConnected = false;
let packetBuffer = new Uint8Array();
let chBuffers = Array.from({length: 8}, () => new Float32Array(FFT_SIZE).fill(0));

// === AUDIO ===
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let synthOsc, synthGain, noiseGain;

function initAudio() {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    
    synthOsc = audioCtx.createOscillator();
    synthOsc.type = 'sine';
    synthOsc.frequency.value = 100;
    synthGain = audioCtx.createGain();
    synthGain.gain.value = 0;
    synthOsc.connect(synthGain).connect(audioCtx.destination);
    synthOsc.start();

    const nBuf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
    const d = nBuf.getChannelData(0);
    for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
    
    const noise = audioCtx.createBufferSource();
    noise.buffer = nBuf;
    noise.loop = true;
    noiseGain = audioCtx.createGain();
    noiseGain.gain.value = 0;
    noise.connect(noiseGain).connect(audioCtx.destination);
    noise.start();
}

// === BLE ===
async function connectBLE() {
    try {
        initAudio();
        document.getElementById('status-text').innerText = "SCANNING...";
        
        const device = await navigator.bluetooth.requestDevice({
            filters:[{ services: [BLE_SERVICE_UUID] }]
        });

        document.getElementById('status-text').innerText = "CONNECTING...";
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_SERVICE_UUID);
        const characteristic = await service.getCharacteristic(BLE_CHAR_UUID);

        await characteristic.startNotifications();
        characteristic.addEventListener('characteristicvaluechanged', onDataReceived);

        device.addEventListener('gattserverdisconnected', () => {
            document.getElementById('status-text').innerText = "DISCONNECTED";
            document.getElementById('ui-layer').style.opacity = 1;
            document.getElementById('ui-layer').style.display = 'block';
            isConnected = false;
        });

        document.getElementById('status-text').innerText = "CONNECTED";
        document.getElementById('ui-layer').style.opacity = 0;
        setTimeout(() => document.getElementById('ui-layer').style.display = 'none', 500);
        
        isConnected = true;
        drawLoop();

    } catch (error) {
        alert("Error: " + error.message);
    }
}

function onDataReceived(event) {
    const value = new Uint8Array(event.target.value.buffer);
    const temp = new Uint8Array(packetBuffer.length + value.length);
    temp.set(packetBuffer);
    temp.set(value, packetBuffer.length);
    packetBuffer = temp;

    while (packetBuffer.length >= 33) {
        let found = false;
        for (let i = 0; i < packetBuffer.length - 32; i++) {
            if (packetBuffer[i] === 0xA0 && packetBuffer[i+32] === 0xC0) {
                parsePacket(packetBuffer.slice(i, i+33));
                packetBuffer = packetBuffer.slice(i + 33);
                found = true;
                break; 
            }
        }
        if (!found) {
            if (packetBuffer.length > 100) packetBuffer = packetBuffer.slice(-32);
            break;
        }
    }
}

function parsePacket(pkt) {
    for (let i = 0; i < CHANNELS; i++) {
        let val = (pkt[2 + i*3] << 16) | (pkt[3 + i*3] << 8) | pkt[4 + i*3];
        if ((val & 0x800000) > 0) val = val - 0x1000000;
        const uV = val * UV_SCALE;
        chBuffers[i].set(chBuffers[i].subarray(1));
        chBuffers[i][FFT_SIZE-1] = uV;
    }
}

// === RESIZE & DRAW ===
const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d', { alpha: false });
let w, h, cx, cy, rad;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    w = canvas.width;
    h = canvas.height;
    cx = w / 2;
    cy = h / 2;
    rad = Math.min(cx, cy) * 0.95;
}
window.addEventListener('resize', resize);
resize();

const win = new Float32Array(FFT_SIZE);
for(let i=0; i<FFT_SIZE; i++) win[i] = 0.5*(1-Math.cos(2*Math.PI*i/(FFT_SIZE-1)));

function drawLoop() {
    if(!isConnected) return;

    // 1. DSP
    const signal = new Float32Array(FFT_SIZE);
    for(let i=0; i<FFT_SIZE; i++) {
        let sum = 0;
        for(let c=0; c<CHANNELS; c++) sum += chBuffers[c][i];
        signal[i] = sum / CHANNELS;
    }

    // 2. FFT
    const mags = new Float32Array(FFT_SIZE/2);
    const phases = new Float32Array(FFT_SIZE/2);
    
    for(let k=0; k<FFT_SIZE/2; k++) {
        let re=0, im=0;
        for(let n=0; n<FFT_SIZE; n++) {
            const phi = (2*Math.PI*k*n)/FFT_SIZE;
            // ИСПРАВЛЕНА ОПЕЧАТКА ЗДЕСЬ (signal[n] вместо sig[n])
            const v = signal[n] * win[n]; 
            re += v * Math.cos(phi);
            im -= v * Math.sin(phi);
        }
        mags[k] = Math.sqrt(re*re + im*im);
        phases[k] = Math.atan2(im, re);
    }

    // 3. ANALYSIS
    let alpha=0, beta=0, gamma=0, domF=0, maxM=0;
    
    for(let k=2; k<mags.length; k++) {
        const f = k * (FS/FFT_SIZE);
        if(f > 70) break;
        const m = mags[k] * (f * 0.5); // Whitening
        
        if(f>=8 && f<=13) alpha += m;
        if(f>=15 && f<=30) beta += m;
        if(f>=35) gamma += m;
        
        if(f<35 && m>maxM) { maxM=m; domF=f; }
    }
    const erd = alpha / (beta + 0.1);

    // 4. AUDIO
    const now = audioCtx.currentTime;
    if(gamma > 200) {
        noiseGain.gain.setTargetAtTime(0.3, now, 0.1);
        synthGain.gain.setTargetAtTime(0, now, 0.1);
    } else {
        noiseGain.gain.setTargetAtTime(0, now, 0.1);
        let vol = (erd > 1.5) ? Math.min(0.8, (erd-1.5)*0.5) : 0;
        synthGain.gain.setTargetAtTime(vol, now, 0.2);
        synthOsc.frequency.setTargetAtTime(80 + domF*8, now, 0.2);
    }

    // 5. RENDER
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
    ctx.fillRect(0, 0, w, h);
    
    ctx.strokeStyle = '#003300';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, rad*0.25, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.5, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.75, 0, Math.PI*2);
    ctx.stroke();

    for(let k=4; k<mags.length; k++) {
        const f = k * (FS/FFT_SIZE);
        if(f > 100) break;
        
        const m = mags[k] * (f * 0.4); 
        const ph = phases[k];
        
        const r = (f / 100.0) * rad;
        const a = ph;
        
        const x = cx + Math.cos(a) * r;
        const y = cy + Math.sin(a) * r;
        
        let hue = 240 - (f * 2.5);
        let size = 4 + m * 0.6;
        let bright = 50;
        
        if(gamma > 200 && f > 30) { hue=0; bright=70; }
        else if(erd > 2.0 && f>=8 && f<=13) { hue=170; bright=80; size*=1.5; }
        
        if(m > 0.5) {
            const opacity = 0.5 + Math.min(0.5, m/10);
            ctx.fillStyle = `hsla(${hue}, 100%, ${bright}%, ${opacity})`;
            
            // Используем fillRect вместо arc для максимальной плавности на мобилке
            ctx.fillRect(x - size/2, y - size/2, size, size);
        }
    }

    requestAnimationFrame(drawLoop);
}

document.getElementById('btn-full').onclick = () => {
    document.documentElement.requestFullscreen();
    setTimeout(resize, 500); 
};
document.getElementById('btn-connect').onclick = connectBLE;

</script>
</body>
</html>
