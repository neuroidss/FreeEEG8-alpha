<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neuro Radar Stable</title>
    <style>
        body { 
            margin: 0; 
            background-color: #000; 
            color: #0f0; 
            font-family: 'Courier New', monospace; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            height: 100vh;
        }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10;
            transition: opacity 0.5s;
        }

        button { 
            pointer-events: auto;
            background: #0f0; 
            color: #000; 
            border: none; 
            padding: 20px 40px; 
            font-size: 20px; 
            font-weight: bold; 
            margin: 10px;
            cursor: pointer; 
            border-radius: 10px;
            text-transform: uppercase;
        }
        
        #status-text {
            color: #fff;
            margin-bottom: 20px;
            font-size: 18px;
        }

        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vw; 
            max-width: 600px; 
            max-height: 600px; 
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="status-text">NEURAL INTERFACE READY</div>
        <button id="btn-full">1. FULLSCREEN</button>
        <button id="btn-connect">2. CONNECT</button>
    </div>

    <canvas id="radar"></canvas>

<script>
// === CONFIG (Original) ===
const BLE_SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const BLE_CHAR_UUID    = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const FS = 250;
const CHANNELS = 8;
const UV_SCALE = (1.2 / 32 / 8388607.0) * 1e6;
const FFT_SIZE = 256; 

// === STATE ===
let isConnected = false;
let channelBuffers = Array.from({ length: CHANNELS }, () => new Float32Array(FFT_SIZE).fill(0));
let packetBuffer = new Uint8Array(); 

// === UI REFS ===
const uiLayer = document.getElementById('ui-layer');
const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d');

// === AUDIO (Simple Drone) ===
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let synthOsc, synthGain, noiseGain;

function initAudio() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    // Synth
    synthOsc = audioCtx.createOscillator();
    synthOsc.type = 'sine';
    synthOsc.frequency.value = 100;
    synthGain = audioCtx.createGain();
    synthGain.gain.value = 0;
    synthOsc.connect(synthGain).connect(audioCtx.destination);
    synthOsc.start();

    // Noise
    const nBuf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
    const d = nBuf.getChannelData(0);
    for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
    const noise = audioCtx.createBufferSource();
    noise.buffer = nBuf;
    noise.loop = true;
    noiseGain = audioCtx.createGain();
    noiseGain.gain.value = 0;
    noise.connect(noiseGain).connect(audioCtx.destination);
    noise.start();
}

// === BLE HANDLER (Original Robust Parser) ===
async function connectBLE() {
    try {
        initAudio();
        document.getElementById('status-text').innerText = "SCANNING...";
        
        const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [BLE_SERVICE_UUID] }]
        });

        document.getElementById('status-text').innerText = "CONNECTING...";
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_SERVICE_UUID);
        const characteristic = await service.getCharacteristic(BLE_CHAR_UUID);

        await characteristic.startNotifications();
        characteristic.addEventListener('characteristicvaluechanged', onDataReceived);

        device.addEventListener('gattserverdisconnected', () => {
            document.getElementById('status-text').innerText = "DISCONNECTED";
            uiLayer.style.display = "flex";
            uiLayer.style.opacity = 1;
            isConnected = false;
        });

        // Hide UI
        uiLayer.style.opacity = 0;
        setTimeout(() => uiLayer.style.display = 'none', 500);
        
        isConnected = true;
        requestAnimationFrame(processLoop);

    } catch (error) {
        alert("Error: " + error.message);
    }
}

// ТОТ САМЫЙ ПАРСЕР ИЗ ДИАГНОСТИКИ
function onDataReceived(event) {
    const value = new Uint8Array(event.target.value.buffer);
    const temp = new Uint8Array(packetBuffer.length + value.length);
    temp.set(packetBuffer);
    temp.set(value, packetBuffer.length);
    packetBuffer = temp;

    while (packetBuffer.length >= 33) {
        let found = false;
        for (let i = 0; i < packetBuffer.length - 32; i++) {
            if (packetBuffer[i] === 0xA0 && packetBuffer[i+32] === 0xC0) {
                parsePacket(packetBuffer.slice(i, i+33));
                packetBuffer = packetBuffer.slice(i + 33);
                found = true;
                break; 
            }
        }
        if (!found) {
            if (packetBuffer.length > 100) packetBuffer = packetBuffer.slice(-32);
            break;
        }
    }
}

function parsePacket(pkt) {
    for (let i = 0; i < CHANNELS; i++) {
        let val = (pkt[2 + i*3] << 16) | (pkt[3 + i*3] << 8) | pkt[4 + i*3];
        if ((val & 0x800000) > 0) val = val - 0x1000000;
        const uV = val * UV_SCALE;
        channelBuffers[i].set(channelBuffers[i].subarray(1));
        channelBuffers[i][FFT_SIZE-1] = uV;
    }
}

// === VISUALS (Standard Radar) ===
let w, h, cx, cy, rad;
function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    cx = w/2; cy = h/2;
    rad = Math.min(cx, cy) * 0.9;
}
window.addEventListener('resize', resize);
resize();

function processLoop() {
    if (!isConnected) { requestAnimationFrame(processLoop); return; }

    // 1. Mean Signal
    const signal = new Float32Array(FFT_SIZE);
    for (let i = 0; i < FFT_SIZE; i++) {
        let sum = 0;
        for(let ch=0; ch<CHANNELS; ch++) sum += channelBuffers[ch][i];
        signal[i] = sum / CHANNELS;
    }

    // 2. FFT
    const { mags, phases } = computeFFT(signal);

    // 3. Render
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // Trails
    ctx.fillRect(0, 0, w, h);
    
    ctx.strokeStyle = '#003300';
    ctx.beginPath();
    ctx.arc(cx, cy, rad*0.25, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.5, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*1.0, 0, Math.PI*2);
    ctx.stroke();

    let alpha = 0, beta = 0, gamma = 0, domF = 0, maxM = 0;

    for (let i = 2; i < mags.length; i++) {
        const f = i * (FS / FFT_SIZE);
        if (f > 60) break;

        const amp = mags[i];
        if (f >= 8 && f <= 13) alpha += amp;
        if (f >= 15 && f <= 30) beta += amp;
        if (f >= 35) gamma += amp;
        
        if (f < 35 && amp > maxM) { maxM = amp; domF = f; }

        const angle = phases[i];
        const dist = (f / 60.0) * rad;
        const x = cx + Math.cos(angle) * dist;
        const y = cy + Math.sin(angle) * dist;

        // VISIBILITY FIX: Minimum size and opacity
        const size = 4 + Math.min(15, amp); 
        const opacity = 0.5 + Math.min(0.5, amp / 5.0);
        
        const hue = 240 - (f * 4); 
        ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${opacity})`;
        
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI*2);
        ctx.fill();
    }

    // 4. Feedback
    const erd = alpha / (beta + 0.01);
    
    // Muscle Noise
    if (gamma > 150) {
        noiseGain.gain.setTargetAtTime(0.3, audioCtx.currentTime, 0.1);
        synthGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
    } else {
        noiseGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
        // Alpha Drone
        if (erd > 1.5) {
            synthGain.gain.setTargetAtTime(0.4, audioCtx.currentTime, 0.2);
            synthOsc.frequency.setTargetAtTime(80 + domF*8, audioCtx.currentTime, 0.2);
        } else {
            synthGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2);
        }
    }

    requestAnimationFrame(processLoop);
}

// Simple FFT
function computeFFT(inData) {
    const N = inData.length;
    const mags = new Float32Array(N/2);
    const phases = new Float32Array(N/2);
    const win = new Float32Array(N);
    for(let i=0;i<N;i++) win[i] = 0.5*(1-Math.cos(2*Math.PI*i/(N-1)));

    for (let k=0; k<N/2; k++) {
        let re=0, im=0;
        for (let n=0; n<N; n++) {
            const phi = (2*Math.PI*k*n)/N;
            re += inData[n]*win[n]*Math.cos(phi);
            im -= inData[n]*win[n]*Math.sin(phi);
        }
        mags[k] = Math.sqrt(re*re + im*im);
        phases[k] = Math.atan2(im, re);
    }
    return { mags, phases };
}

// Handlers
document.getElementById('btn-full').onclick = () => document.documentElement.requestFullscreen();
document.getElementById('btn-connect').onclick = connectBLE;

</script>
</body>
</html>
