<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HoloRadar Final</title>
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'Courier New', monospace;
            touch-action: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85); z-index: 10;
            transition: opacity 0.5s;
        }
        
        button {
            background: rgba(0, 255, 0, 0.2); color: #0f0;
            border: 2px solid #0f0; padding: 20px 40px;
            font-size: 20px; font-weight: bold; border-radius: 50px;
            margin: 15px; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 20px #0f0;
        }
        button:active { background: #0f0; color: #000; }
        
        #hud {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 2px #000;
        }
        .stat-main { font-size: 16px; color: #888; }
        .stat-val { color: #fff; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1 style="color:white; text-shadow: 0 0 10px #fff; margin-bottom: 40px;">NEURO PERFORMANCE</h1>
    <button id="btn-full">1. FULLSCREEN</button>
    <button id="btn-conn">2. START</button>
</div>

<div id="hud">
    <span class="stat-main">STATUS: <span id="st-conn" class="stat-val">WAITING</span></span> |
    <span class="stat-main">ERD: <span id="st-erd" class="stat-val">0.0</span></span>
</div>

<canvas id="cvs"></canvas>

<script>
// === CONFIG ===
const BLE_SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const BLE_CHAR_UUID    = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const FS = 250;
const FFT_SIZE = 256;
const CHANNELS = 8;
const UV_SCALE = (1.2 / 32 / 8388607.0) * 1e6;

// === STATE ===
let isConnected = false;
let packetBuffer = new Uint8Array();
let chBuffers = Array.from({length: 8}, () => new Float32Array(FFT_SIZE).fill(0));

// === AUDIO ENGINE ===
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let synthOsc, synthGain, noiseGain;

function initAudio() {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    
    // Alpha Drone
    synthOsc = audioCtx.createOscillator();
    synthGain = audioCtx.createGain();
    synthOsc.connect(synthGain).connect(audioCtx.destination);
    synthOsc.type = 'sine';
    synthOsc.frequency.value = 100;
    synthGain.gain.value = 0;
    synthOsc.start();

    // Muscle Noise
    const nBuf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
    const d = nBuf.getChannelData(0);
    for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
    
    const noise = audioCtx.createBufferSource();
    noise.buffer = nBuf;
    noise.loop = true;
    noiseGain = audioCtx.createGain();
    noiseGain.gain.value = 0;
    noise.connect(noiseGain).connect(audioCtx.destination);
    noise.start();
}

// === BLE CONNECTION (PARSER FROM DIAGNOSTIC VERSION) ===
async function connectBLE() {
    try {
        initAudio();
        const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [BLE_SERVICE_UUID] }]
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(BLE_SERVICE_UUID);
        const char = await service.getCharacteristic(BLE_CHAR_UUID);
        
        await char.startNotifications();
        char.addEventListener('characteristicvaluechanged', onDataReceived);
        
        // Hide UI
        document.getElementById('ui-layer').style.opacity = 0;
        setTimeout(() => document.getElementById('ui-layer').style.display = 'none', 500);
        document.getElementById('st-conn').innerText = "STREAMING";
        document.getElementById('st-conn').style.color = "#00ffcc";
        
        isConnected = true;
        drawLoop();
    } catch(e) {
        alert("Connection Error: " + e);
    }
}

// ЭТОТ ПАРСЕР ТОЧНО РАБОТАЕТ (ИЗ ДИАГНОСТИКИ)
function onDataReceived(event) {
    const value = new Uint8Array(event.target.value.buffer);
    const temp = new Uint8Array(packetBuffer.length + value.length);
    temp.set(packetBuffer);
    temp.set(value, packetBuffer.length);
    packetBuffer = temp;

    while (packetBuffer.length >= 33) {
        let found = false;
        for (let i = 0; i < packetBuffer.length - 32; i++) {
            if (packetBuffer[i] === 0xA0 && packetBuffer[i+32] === 0xC0) {
                parsePacket(packetBuffer.slice(i, i+33));
                packetBuffer = packetBuffer.slice(i + 33);
                found = true;
                break; 
            }
        }
        if (!found) {
            if (packetBuffer.length > 100) packetBuffer = packetBuffer.slice(-32);
            break;
        }
    }
}

function parsePacket(pkt) {
    for (let i = 0; i < CHANNELS; i++) {
        let val = (pkt[2 + i*3] << 16) | (pkt[3 + i*3] << 8) | pkt[4 + i*3];
        if ((val & 0x800000) > 0) val = val - 0x1000000;
        
        const uV = val * UV_SCALE;
        
        chBuffers[i].set(chBuffers[i].subarray(1));
        chBuffers[i][FFT_SIZE-1] = uV;
    }
}

// === VISUALIZATION & DSP ===
const canvas = document.getElementById('cvs');
const ctx = canvas.getContext('2d', { alpha: false });
let w, h, cx, cy, rad;

function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    cx = w/2; cy = h/2;
    rad = Math.min(cx, cy) * 0.95;
}
window.onresize = resize;
resize();

// Window function
const win = new Float32Array(FFT_SIZE);
for(let i=0; i<FFT_SIZE; i++) win[i] = 0.5*(1-Math.cos(2*Math.PI*i/(FFT_SIZE-1)));

function drawLoop() {
    if(!isConnected) return;

    // 1. DSP: Bipolar Mean
    const sig = new Float32Array(FFT_SIZE);
    for(let i=0; i<FFT_SIZE; i++) {
        let s = 0;
        for(let c=0; c<8; c++) s += (chBuffers[c][i] - chBuffers[(c+1)%8][i]);
        sig[i] = s/8.0;
    }

    // 2. FFT
    const mags = new Float32Array(FFT_SIZE/2);
    const phases = new Float32Array(FFT_SIZE/2);
    
    for(let k=0; k<FFT_SIZE/2; k++) {
        let re=0, im=0;
        for(let n=0; n<FFT_SIZE; n++) {
            const phi = (2*Math.PI*k*n)/FFT_SIZE;
            const v = sig[n] * win[n];
            re += v * Math.cos(phi);
            im -= v * Math.sin(phi);
        }
        mags[k] = Math.sqrt(re*re + im*im);
        phases[k] = Math.atan2(im, re);
    }

    // 3. ANALYSIS
    let alpha=0, beta=0, gamma=0;
    let domF=0, maxM=0;
    
    for(let k=2; k<mags.length; k++) {
        const f = k * (FS/FFT_SIZE);
        if(f > 70) break;
        const m = mags[k] * (f * 0.5); // Whitening
        
        if(f>=8 && f<=13) alpha += m;
        if(f>=15 && f<=30) beta += m;
        if(f>=35) gamma += m;
        
        if(f<35 && m>maxM) { maxM=m; domF=f; }
    }
    const erd = alpha / (beta + 0.1);
    document.getElementById('st-erd').innerText = erd.toFixed(2);

    // 4. AUDIO FEEDBACK
    const now = audioCtx.currentTime;
    if(gamma > 200) {
        noiseGain.gain.setTargetAtTime(0.3, now, 0.1);
        synthGain.gain.setTargetAtTime(0, now, 0.1);
        document.getElementById('st-conn').style.color = "red";
        document.getElementById('st-conn').innerText = "MUSCLE";
    } else {
        noiseGain.gain.setTargetAtTime(0, now, 0.2);
        // Звук громче
        let vol = (erd > 1.5) ? Math.min(0.8, (erd-1.5)*0.5) : 0;
        synthGain.gain.setTargetAtTime(vol, now, 0.3);
        synthOsc.frequency.setTargetAtTime(80 + domF*8, now, 0.3);
        
        if(erd > 1.5) {
            document.getElementById('st-conn').style.color = "#00ffcc";
            document.getElementById('st-conn').innerText = "ALPHA";
        } else {
            document.getElementById('st-conn').style.color = "#aaa";
            document.getElementById('st-conn').innerText = "FOCUS";
        }
    }

    // 5. RENDER
    // Fade effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
    ctx.fillRect(0, 0, w, h);
    
    // Grid
    ctx.strokeStyle = '#003300';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, rad*0.25, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.5, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.75, 0, Math.PI*2);
    ctx.stroke();

    // Particles (High Visibility Mode)
    for(let k=4; k<mags.length; k++) {
        const f = k * (FS/FFT_SIZE);
        if(f > 100) break;
        
        const m = mags[k] * (f * 0.4); 
        const ph = phases[k];
        
        const r = (f / 100.0) * rad;
        const a = ph;
        
        const x = cx + Math.cos(a) * r;
        const y = cy + Math.sin(a) * r;
        
        // Colors
        let hue = 240 - (f * 2.5);
        let size = 4 + m * 0.6;
        let bright = 60;
        
        if(gamma > 200 && f > 30) { hue=0; bright=70; }
        else if(erd > 2.0 && f>=8 && f<=13) { hue=170; bright=80; size*=1.5; }
        
        // Рисуем, даже если сигнал слабый (min opacity 0.4)
        if(m > 0.5) {
            const opacity = 0.4 + Math.min(0.6, m/10);
            ctx.fillStyle = `hsla(${hue}, 100%, ${bright}%, ${opacity})`;
            ctx.fillRect(x - size/2, y - size/2, size, size);
        }
    }

    requestAnimationFrame(drawLoop);
}

// UI Handlers
document.getElementById('btn-full').onclick = () => document.documentElement.requestFullscreen();
document.getElementById('btn-conn').onclick = connectBLE;

</script>
</body>
</html>
