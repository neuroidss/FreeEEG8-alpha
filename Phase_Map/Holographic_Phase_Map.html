<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HoloRadar Optimized</title>
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'Courier New', monospace;
            touch-action: none; /* Блокируем зум */
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85); z-index: 10;
            transition: opacity 0.5s;
        }
        
        button {
            background: rgba(0, 255, 204, 0.1); color: #00ffcc;
            border: 2px solid #00ffcc; padding: 20px 40px;
            font-size: 20px; font-weight: bold; border-radius: 50px;
            margin: 15px; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
            backdrop-filter: blur(5px);
        }
        button:active { background: #00ffcc; color: #000; }
        
        #hud {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 2px #000;
        }
        .stat-main { font-size: 16px; color: #888; }
        .stat-val { color: #fff; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    <h1 style="color:white; text-shadow: 0 0 10px #fff; margin-bottom: 40px;">HOLO-RADAR GPU</h1>
    <button id="btn-full">1. GO FULLSCREEN</button>
    <button id="btn-conn">2. CONNECT BLE</button>
</div>

<div id="hud">
    <span class="stat-main">STATUS: <span id="st-conn" class="stat-val">WAITING</span></span> |
    <span class="stat-main">ERD: <span id="st-erd" class="stat-val">0.0</span></span>
</div>

<canvas id="cvs"></canvas>

<script>
// === CONFIGURATION ===
const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const CHAR_UUID    = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const FS = 250;
const FFT_SIZE = 256;
const CHANNELS = 8;
const UV_SCALE = (1.2 / 32 / 8388607.0) * 1e6;

// === STATE ===
let isRunning = false;
let packetBuffer = new Uint8Array();
let chBuffers = Array.from({length: 8}, () => new Float32Array(FFT_SIZE).fill(0));

// === AUDIO ENGINE ===
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let synthOsc, synthGain, noiseGain;

function initAudio() {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    
    // Alpha Drone
    synthOsc = audioCtx.createOscillator();
    synthGain = audioCtx.createGain();
    synthOsc.connect(synthGain).connect(audioCtx.destination);
    synthOsc.type = 'sine';
    synthOsc.frequency.value = 100;
    synthGain.gain.value = 0;
    synthOsc.start();

    // Muscle Noise
    const nBuf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
    const d = nBuf.getChannelData(0);
    for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
    
    const noise = audioCtx.createBufferSource();
    noise.buffer = nBuf;
    noise.loop = true;
    noiseGain = audioCtx.createGain();
    noiseGain.gain.value = 0;
    noise.connect(noiseGain).connect(audioCtx.destination);
    noise.start();
}

// === BLE CONNECTION (Proven Working Parser) ===
async function connectBLE() {
    try {
        initAudio();
        const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [SERVICE_UUID] }]
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        const char = await service.getCharacteristic(CHAR_UUID);
        
        await char.startNotifications();
        char.addEventListener('characteristicvaluechanged', onData);
        
        // UI Transition
        document.getElementById('ui').style.opacity = 0;
        setTimeout(() => document.getElementById('ui').style.display = 'none', 500);
        document.getElementById('st-conn').innerText = "STREAMING";
        document.getElementById('st-conn').style.color = "#00ffcc";
        
        isRunning = true;
        drawLoop();
    } catch(e) {
        alert("Connection Error: " + e);
    }
}

function onData(e) {
    const val = new Uint8Array(e.target.value.buffer);
    const tmp = new Uint8Array(packetBuffer.length + val.length);
    tmp.set(packetBuffer); tmp.set(val, packetBuffer.length);
    packetBuffer = tmp;
    
    // Robust parsing loop from Hyper-Web
    while(packetBuffer.length >= 33) {
        let head = -1;
        for(let i=0; i<packetBuffer.length-32; i++) {
            if(packetBuffer[i]===0xA0 && packetBuffer[i+32]===0xC0) {
                head = i; break;
            }
        }
        
        if(head === -1) {
            if(packetBuffer.length > 66) packetBuffer = packetBuffer.slice(-33);
            break;
        }
        
        if(head > 0) {
            packetBuffer = packetBuffer.slice(head);
            continue;
        }
        
        // Parse 8 channels
        for(let ch=0; ch<8; ch++) {
            let v = (packetBuffer[2+ch*3]<<16) | (packetBuffer[3+ch*3]<<8) | packetBuffer[4+ch*3];
            if(v & 0x800000) v -= 0x1000000;
            // Update Ring Buffer
            chBuffers[ch].set(chBuffers[ch].subarray(1));
            chBuffers[ch][FFT_SIZE-1] = v * UV_SCALE;
        }
        
        packetBuffer = packetBuffer.slice(33);
    }
}

// === RENDER & DSP ===
const canvas = document.getElementById('cvs');
const ctx = canvas.getContext('2d', { alpha: false });
let w, h, cx, cy, rad;

function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    cx = w/2; cy = h/2;
    rad = Math.min(cx, cy) * 0.95;
}
window.onresize = resize;
resize();

// Pre-calc Window
const win = new Float32Array(FFT_SIZE);
for(let i=0; i<FFT_SIZE; i++) win[i] = 0.5*(1-Math.cos(2*Math.PI*i/(FFT_SIZE-1)));

function drawLoop() {
    if(!isRunning) return;

    // 1. DSP: Calculate Mean Signal (Common mode rejection via averaging)
    const sig = new Float32Array(FFT_SIZE);
    // Use simple averaging or bipolar loop. Bipolar is cleaner:
    for(let i=0; i<FFT_SIZE; i++) {
        let s = 0;
        for(let c=0; c<8; c++) s += (chBuffers[c][i] - chBuffers[(c+1)%8][i]);
        sig[i] = s/8.0;
    }

    // 2. FFT
    const mags = new Float32Array(FFT_SIZE/2);
    const phases = new Float32Array(FFT_SIZE/2);
    
    for(let k=0; k<FFT_SIZE/2; k++) {
        let re=0, im=0;
        for(let n=0; n<FFT_SIZE; n++) {
            const phi = (2*Math.PI*k*n)/FFT_SIZE;
            const v = sig[n] * win[n];
            re += v * Math.cos(phi);
            im -= v * Math.sin(phi);
        }
        mags[k] = Math.sqrt(re*re + im*im);
        phases[k] = Math.atan2(im, re);
    }

    // 3. Audio & Metrics
    let alpha=0, beta=0, gamma=0;
    let domF=0, maxM=0;
    
    for(let k=2; k<mags.length; k++) {
        const f = k * (FS/FFT_SIZE);
        if(f > 70) break;
        const m = mags[k] * (f * 0.5); // Whitening
        
        if(f>=8 && f<=13) alpha += m;
        if(f>=15 && f<=30) beta += m;
        if(f>=35) gamma += m;
        
        if(f<35 && m>maxM) { maxM=m; domF=f; }
    }
    const erd = alpha / (beta + 0.1);
    document.getElementById('st-erd').innerText = erd.toFixed(2);

    // Audio Feedback
    const now = audioCtx.currentTime;
    if(gamma > 200) {
        noiseGain.gain.setTargetAtTime(0.3, now, 0.1);
        synthGain.gain.setTargetAtTime(0, now, 0.1);
        document.getElementById('st-conn').style.color = "red";
        document.getElementById('st-conn').innerText = "MUSCLE";
    } else {
        noiseGain.gain.setTargetAtTime(0, now, 0.2);
        let vol = (erd > 1.5) ? Math.min(0.8, (erd-1.5)*0.5) : 0;
        synthGain.gain.setTargetAtTime(vol, now, 0.2);
        synthOsc.frequency.setTargetAtTime(80 + domF*8, now, 0.2);
        
        if(erd > 1.5) {
            document.getElementById('st-conn').style.color = "#00ffcc";
            document.getElementById('st-conn').innerText = "ALPHA";
        } else {
            document.getElementById('st-conn').style.color = "#aaa";
            document.getElementById('st-conn').innerText = "FOCUS";
        }
    }

    // 4. RENDER (GPU Accelerated)
    
    // Trails
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; 
    ctx.fillRect(0, 0, w, h);
    
    // Additive Glow
    ctx.globalCompositeOperation = 'lighter';
    
    // Grid
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, rad*0.25, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.5, 0, Math.PI*2);
    ctx.arc(cx, cy, rad*0.75, 0, Math.PI*2);
    ctx.stroke();

    // Radar Particles
    for(let k=4; k<mags.length; k++) {
        const f = k * (FS/FFT_SIZE);
        if(f > 100) break;
        
        const m = mags[k] * (f * 0.4); // Whitening
        const ph = phases[k];
        
        const r = (f / 100.0) * rad;
        const a = ph; // Phase = Angle
        
        const x = cx + Math.cos(a) * r;
        const y = cy + Math.sin(a) * r;
        
        // Color Mapping
        let hue = 240 - (f * 2.5);
        let size = 3 + m * 0.5;
        let bright = 50;
        
        if(gamma > 200 && f > 30) { hue=0; bright=70; } // EMG
        else if(erd > 2.0 && f>=8 && f<=13) { hue=170; bright=80; size*=1.5; } // Alpha
        
        if(m > 1.0) {
            ctx.fillStyle = `hsla(${hue}, 100%, ${bright}%, ${Math.min(1, m/10)})`;
            // Using fillRect for speed
            ctx.fillRect(x - size/2, y - size/2, size, size);
        }
    }

    requestAnimationFrame(drawLoop);
}

// UI Handlers
document.getElementById('btn-full').onclick = () => document.documentElement.requestFullscreen();
document.getElementById('btn-conn').onclick = connectBLE;

</script>
</body>
</html>
